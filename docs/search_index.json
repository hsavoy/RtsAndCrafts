[["index.html", "Rts and Crafts 1 Preface", " Rts and Crafts H. Savoy 2020-11-03 1 Preface This book catalogs different art projects that have been augmented (or overly-complicated?) by R. Many ideas come from conversations at the monthly Las Cruces/El Paso RLadies meetings. Hit me up if you want to join in. All code (including this book!) is available at hsavoy/rtsAndCrafts. "],["paintByNumbers.html", "2 Auto-generating Paint-by-Numbers Instructions 2.1 Introduction 2.2 Packages being used 2.3 Step 1: Reading in the image 2.4 Step 2: Reducing the number of colors 2.5 Step 3: Converting the image into polygons of the same color 2.6 Future expansions:", " 2 Auto-generating Paint-by-Numbers Instructions 2.1 Introduction This project aims to convert an image (e.g., of my cat) into paint-by-number instructions. This involves: reducing the number of colors down to a reasonable number, i.e. reducing the 16+ million colors possible with 8-bit images down to like 10-15, converting raster data into polygons based on those limited colors, and saving those resulting polygons with their color IDs as printable and readable instructions. This document follows the adventure of getting it all to work. 2.2 Packages being used The packages we load are all on CRAN. raster has handy functions for handling and viewing images, sf and smoothr help with handling the polygons, and tidyverse has general grammar for tidy data manipulation. Disclaimer: there are probably more packages out there that do similar things, but I'm coming from a geospatial day job and I'm using these packages since there are already familiar to me. Other packages needed for dependencies are rgdal and rgeos. library(raster) library(sf) library(tidyverse) library(smoothr) library(units) library(ggthemes) # add to text above library(wesanderson) library(rdist) 2.3 Step 1: Reading in the image img &lt;- brick(&quot;../images/byxbee_loaf.jpg&quot;) %&gt;% aggregate(25) # reducing the resolution up front to save time plotRGB(img) 2.4 Step 2: Reducing the number of colors 2.4.1 Attempt 1: just rounding the individual RGB values cutoff &lt;- 75 # number to rount to rounded_img &lt;- img # make a copy of the orignal image object values(rounded_img) &lt;- values(img) %&gt;% # extract values from image (strip spatial component) as_tibble() %&gt;% #converting the matrix to tibble for tidy data manipulation mutate_all(~cutoff*floor(./cutoff)) %&gt;% # overwrite all values to rounded down values to cutoff as.matrix() # convert back to matrix plotRGB(rounded_img) Well it worked in that we can still see the cat and there are &lt;20 unique colors, but its not the ideal result. 2.4.2 Attempt 2: using kmeans clustering N &lt;- 8 # number of colors img_clust &lt;- values(img) %&gt;% kmeans(N, iter.max = 50) centroids_img &lt;- img values(centroids_img) &lt;- img_clust$cluster %&gt;% enframe(name = NULL) %&gt;% left_join(img_clust$centers %&gt;% as_tibble(rownames = &quot;value&quot;) %&gt;% mutate(value = as.numeric(value))) %&gt;% mutate_all(~round(.,0)) %&gt;% as.matrix() plotRGB(centroids_img[[-1]]) # I&#39;m skipping the first layer that contains the cluster ID That's a bit better. But what if we have a set palette we want to use? 2.4.3 Attempt 3: specifying a palette first I haven't tried this yet, but the plan is to see if we can split the colors from the image into a pre-defined set of colors. Maybe cool ones like the Wes Anderson pallete or matching to paint sets to make painting the printed result more feasible. An initial attempt with the Isle of Dogs palette: N &lt;- 15 # number of colors (wes_pal &lt;- wes_palette(&quot;IsleofDogs1&quot;, N, type = &quot;continuous&quot;)) wes_rgb &lt;- wes_pal[1:N] %&gt;% col2rgb() %&gt;% t() img_wes &lt;- values(img) %&gt;% cdist(wes_rgb) %&gt;% as_tibble() %&gt;% rowwise() %&gt;% mutate(cluster = which.min(c_across(everything()))) %&gt;% pull(cluster) def_pal_img &lt;- img values(def_pal_img) &lt;- img_wes %&gt;% enframe(name = NULL) %&gt;% left_join(wes_rgb %&gt;% as_tibble(rownames = &quot;value&quot;) %&gt;% mutate(value = as.numeric(value))) %&gt;% mutate_all(~round(.,0)) %&gt;% as.matrix() plotRGB(def_pal_img[[-1]]) 2.5 Step 3: Converting the image into polygons of the same color poly_img &lt;- rasterToPolygons(def_pal_img$value, dissolve = TRUE, digits = 0) st_img &lt;- poly_img %&gt;% st_as_sf() %&gt;% st_buffer(5) %&gt;% st_simplify(TRUE,dTolerance = 15) %&gt;% #simplifies lines by removing vertices #drop_crumbs(threshold = 10 ) %&gt;% # these sound applicable but I keep getting error messages! #fill_holes(threshold = 10) %&gt;% smooth(method = &quot;ksmooth&quot;, smoothness = 0.5) %&gt;% st_cast(&quot;POLYGON&quot;) # clust_cols &lt;- img_clust$centers %&gt;% # as_tibble(rownames = &quot;value&quot;) %&gt;% # mutate(hex = rgb(byxbee_loaf.1/255,byxbee_loaf.2/255,byxbee_loaf.3/255)) %&gt;% # pull(hex) # # img_pal &lt;- function(n){ # return(clust_cols[1:n]) # } # Try to visualize what the painting would look like st_img %&gt;% plot(pal = wes_pal[1:N],breaks=0:15, # use the palette from the previous section border = NA, # no polygon outlines key.pos=NULL, # no legend main = NULL) # no title So now we need to print the instructions and make sure they are readable on a standard printer paper to make things easy for people. I'm switching to ggplot plotting because it's easier to customize visualizations. st_img %&gt;% ggplot() + geom_sf(fill = NA, color = &quot;black&quot;, # draw lines for polygons size = 0.1) + # fine lines geom_sf_text(aes(label = value), # label color ID per polygon size = 1) + theme_map() # no axes or anything like that This seems like a lot of polygons! We will have to iteratively tweak our simplifications. 2.6 Future expansions: Consider using a machine learning classification approach? Have an option to split skinny images (e.g. panoramic photos) into multiple pages of instructions, which would be helpful for breaking up mural instructions Have an option to have a grid included on the instructions in case people need to transfer the outlines to a large area, e.g. a wall for a mural Have an option to fit a custom piece of paper "],["randomPatterns.html", "3 Randomly Generating Patterns 3.1 Introduction 3.2 Packages being used", " 3 Randomly Generating Patterns 3.1 Introduction I'd like to re-do the backsplash in my kitchen. It's ok tile, but it's a lot of beige. I'd prefer some talavera tiles sprinkled in with white tiles. I'd like to have it be more random than a structured pattern, so I'm going to write some code to randomly generate the location of the colorful tiles. I'm also undecided about the relative size of the tiles I'd want, so I'll play with that here, too. The area is like a tophat shape with two short rectangles on each side a taller and more square shape in the center. I'm going to assume that I only want square tiles so I'll be using rasters to represent the tiles. I just won't be able to visualize grout this way. Does sf have gridded geometry? I'm going to start with the idea that these are all 1 in tiles and that grout is negligible thinkness. The area is 10 ft long with the first 3.5 ft being 2 ft tall, the next 3 ft being 3 ft tall, and the final 3.5 ft being 2 ft all. Insert picture of kitchen here with red or blue lines marking dimensions 3.2 Packages being used library(raster) library(sf) 3.2.1 Step 1: Draw the backsplash domain For sanity's sake, we will consider the bottom left of the backsplash as the origin in our coordinate system. backsplash_length &lt;- 10*12 backsplash_height &lt;- 3*12 backsplash &lt;- raster(nrows = backsplash_height, ncols = backsplash_length, xmn = 0, xmx = backsplash_length, ymn = 0, ymx = backsplash_height, crs = NA, vals = 1) # Where are my cabinets? cabinet_bottom &lt;- 2*12 # 2 ft, at what height the cabinets start cabinet_width &lt;- 3.5*12 # 3.5 ft, how wide the cabinets are cabinet_spacing &lt;- 3*12 # 3 ft, space in between cabinets # Let&#39;s make some intermediate variables just to make the logic clearer tile_x &lt;- coordinates(backsplash)[,1] tile_y &lt;- coordinates(backsplash)[,2] values(backsplash)[ (tile_x &lt; cabinet_width | tile_x &gt; cabinet_width+cabinet_spacing) &amp; tile_y &gt; cabinet_bottom ] &lt;- NA plot(backsplash) 3.2.2 Step 2: Randomly placing talavera tiles # How many tiles I want? N_talavera &lt;- 2*12 # let&#39;s say packages come in by the dozen and I get two tala_x &lt;- runif(N_talavera*2, min = 0, max = backsplash_length) %&gt;% floor() tala_y &lt;- runif(N_talavera*2, min = 0, max = backsplash_height) %&gt;% floor() How do you do that code in another script thing and I just pull in named chunks here? "],["tiltShift.html", "4 Mimicking Tilt-Shift Photography 4.1 Introduction 4.2 Packages being used", " 4 Mimicking Tilt-Shift Photography 4.1 Introduction 4.2 Packages being used 4.2.1 Step 1: Read in the image This will work best if the images we are manipulating have objects near the middle of the image to which we can draw the audience's attention. 4.2.2 Step 2: Define the focal area Basically, we will specify the range of coordinates we want as the focal area (the locator function is handy here!). For simplicity, I'll draw a box over the object in the center of the image: 4.2.3 Step 3: Apply the blurring filter We will have a variable amount of blur: highest near the image borders and decreasing to zero as it approaches the focal area. 4.2.4 Step 4: Modifying the color saturation Any edge detection? "]]
